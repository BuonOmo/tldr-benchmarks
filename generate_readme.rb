#!/usr/bin/env ruby
# frozen_string_literal: true
#
# Generates the README.md file based on
# benchmark results and DATA section at
# the end of this file.
#
# For tests purposes, you can locally
# run this script using fixtures with
# the `test_generation` script.
#

INFO = 'information.tsv'

require 'csv'
require 'erb'
require 'json'
require 'stringio'

def last_commit_time(git_link)
	@last_commit_times ||= {}
	return @last_commit_times[git_link] if @last_commit_times[git_link]

	temp_folder = "tldr-benchmarks-temp-#{git_link.hash}"

	commit_time =
		`
		git clone --no-checkout --depth=1 --quiet #{git_link} #{temp_folder}
		cd #{temp_folder}
		git log -1 --pretty=format:"%as"
		cd ..
		rm -rf #{temp_folder}
		`.chomp

	@last_commit_times[git_link] = commit_time
end

class Array
	def fork_map(&block)
		map { |*a, **kw| Thread.fork { block.call(*a, **kw) } }.map(&:value)
	end
end

def generate_table(hyperfine_output_path, hyperfine_update_path, update_times_path, information_path, stream = $stdout, extra_rows = [])
	results = JSON.load_file(hyperfine_output_path)['results']
	results_update = JSON.load_file(hyperfine_update_path)['results']
	info = CSV.read(information_path, col_sep: "\t", headers: true).to_h { [_1['command'], _1] }
	update_times = CSV.read(update_times_path).to_h

	headers = ["Client","Language", "Time to show `tar` page (mean ± σ)", "Time to Generate Cache", "Time to check for cache update (mean ± σ)", "Last Commit", *extra_rows.map(&:first)]

	rows = results.sort_by { _1['mean'] }.fork_map do |result|
		command = result['command'][%r( \./(.*) tar), 1]
		update = results_update.find { _1['command'][command] }
		info_row = info[command]
		update_times[command][/(\d+)m(\d+)\.(\d+)s/]
		update_time = "%02d:%02d.%d" % [$1.to_i, $2.to_i, $3.to_i]
		[
			"[#{command}](#{info_row['git link']})",
			info_row['lang'],
			"#{(result['mean'] * 1_000).round(1)} ms ± #{(result['stddev'] * 1_000).round(1)}",
			update_time,
			"#{(update['mean'] * 1_000).round(1)} ms ± #{(update['stddev'] * 1_000).round(1)}",
			last_commit_time(info_row['git link']),
			*extra_rows.map { _2.call(command, result, info_row, update_time) },
		]
	end

	col_widths = headers.zip(*rows).map { |cols| cols.map { _1.to_s.length }.max }

	stream.puts "| #{headers.zip(col_widths).map { _1.to_s.ljust(_2, ' ') }.join(' | ')} |"
	stream.puts "| #{col_widths.map { '-' * _1 }.join(' | ')} |"
	rows.each do |row|
		stream.puts "| #{row.zip(col_widths).map { _1.to_s.ljust(_2, ' ') }.join(' | ')} |"
	end
end

io = StringIO.new
generate_table(*ARGV[0, 3], INFO, io, [
	["Comment", ->(_, _, info, _) { info['comment mac'] }]
])
mac_table = io.string

io = StringIO.new
generate_table(*ARGV[3, 3], INFO, io, [
	["Comment", ->(_, _, info, _) { info['comment ubuntu'] }]
])
ubuntu_table = io.string

File.write('README.md', ERB.new(DATA.read).result(binding))

__END__
<!--
	This File is auto-generated by `generate_readme.rb`.
	If you want to update it, please first update the
	end of `generate_readme.rb` and then run the CI to
	regenarate this file.
-->
# TLDR Benchmarks

A collection of benchmarks for the various TLDR implementations.

These benchmarks aim to provide a comparison for one who wants to
choose an implementation based on overall performance, installation
time and project maintenance.

## For Mac OS X

<%= mac_table %>

## For Ubuntu

<%= ubuntu_table %>
